{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 구조화",
        "description": "Next.js, React, TypeScript, shadcn/ui 기반의 프로젝트 초기 설정 및 폴더 구조 구성",
        "details": "1. Next.js App Router 구조로 프로젝트 생성\n2. TypeScript 설정 및 tsconfig.json 구성\n3. shadcn/ui 설치 및 테마 설정\n4. React Query 설정 및 글로벌 프로바이더 구성\n5. Zod 스키마 기본 구조 설정\n6. 공유 DTO 패키지 구조 설정 (/packages/sdk)\n7. 기본 레이아웃 컴포넌트 구현\n8. 환경 변수 설정 (.env 파일 구성)\n\n```tsx\n// app/layout.tsx\nimport { ThemeProvider } from '@/components/theme-provider'\nimport { QueryProvider } from '@/components/query-provider'\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"ko\">\n      <body>\n        <ThemeProvider>\n          <QueryProvider>{children}</QueryProvider>\n        </ThemeProvider>\n      </body>\n    </html>\n  )\n}\n```",
        "testStrategy": "1. 프로젝트 빌드 및 개발 서버 실행 테스트\n2. TypeScript 타입 검사 확인\n3. 기본 컴포넌트 렌더링 테스트\n4. 환경 변수 로드 테스트",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "네트워크 통신 레이어 구현",
        "description": "API 통신을 위한 fetch/ky 래퍼 구현 및 401 인증 오류 인터셉터 설정",
        "details": "1. ky 라이브러리 설치 및 기본 설정\n2. 인증 토큰 관리 및 요청 헤더에 추가하는 로직 구현\n3. 401 오류 인터셉터 구현 (세션 만료 시 로그인 페이지로 리다이렉트)\n4. API 엔드포인트 상수 정의\n5. 타입 안전한 API 호출 함수 구현\n\n```tsx\n// lib/api.ts\nimport ky from 'ky';\n\nconst api = ky.create({\n  prefixUrl: process.env.NEXT_PUBLIC_API_URL,\n  hooks: {\n    beforeRequest: [\n      request => {\n        const token = getAuthToken();\n        if (token) {\n          request.headers.set('Authorization', `Bearer ${token}`);\n        }\n      }\n    ],\n    afterResponse: [\n      async (request, options, response) => {\n        if (response.status === 401) {\n          // 세션 만료 처리\n          clearAuthToken();\n          window.location.href = '/login';\n        }\n        return response;\n      }\n    ]\n  }\n});\n\nexport default api;\n```",
        "testStrategy": "1. API 요청 성공 및 실패 시나리오 테스트\n2. 인증 토큰 자동 추가 테스트\n3. 401 응답 시 리다이렉트 동작 테스트\n4. 모의 서버(MSW)를 사용한 API 통합 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Supabase 인증 통합 구현",
        "description": "Supabase Auth를 사용한 사용자 인증 및 세션 관리 구현",
        "details": "1. Supabase 클라이언트 설정\n2. 로그인/회원가입 폼 구현\n3. 세션 상태 관리 및 컨텍스트 제공자 구현\n4. 인증 보호 라우트 구현\n5. 액세스 토큰 관리 및 API 요청 헤더에 추가\n6. 로그아웃 기능 구현\n\n```tsx\n// lib/supabase.ts\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\n\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\n\n// components/auth-provider.tsx\nimport { createContext, useContext, useEffect, useState } from 'react';\nimport { supabase } from '@/lib/supabase';\n\nconst AuthContext = createContext(null);\n\nexport function AuthProvider({ children }) {\n  const [session, setSession] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(\n      (event, session) => {\n        setSession(session);\n        setLoading(false);\n      }\n    );\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  return (\n    <AuthContext.Provider value={{ session, loading }}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n```",
        "testStrategy": "1. 로그인/회원가입 플로우 테스트\n2. 세션 지속성 테스트\n3. 보호된 라우트 접근 테스트\n4. 로그아웃 기능 테스트\n5. 인증 상태 변경 시 UI 업데이트 테스트",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "워크스페이스 및 역할 관리 구현",
        "description": "워크스페이스 전환 기능 및 소유자/관리자/멤버 역할 관리 시스템 구현",
        "details": "1. 워크스페이스 선택 UI 컴포넌트 구현\n2. 워크스페이스 전환 기능 구현\n3. 사용자 역할(소유자/관리자/멤버) 관리 로직 구현\n4. 역할 기반 UI 조건부 렌더링 구현\n5. 워크스페이스 생성 및 관리 기능 구현\n6. 워크스페이스 멤버 초대 및 관리 기능 구현\n\n```tsx\n// components/workspace-switcher.tsx\nimport { useState, useEffect } from 'react';\nimport { useQuery } from '@tanstack/react-query';\nimport { Check, ChevronsUpDown } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { Command, CommandGroup, CommandItem } from '@/components/ui/command';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport { fetchWorkspaces, setCurrentWorkspace } from '@/lib/api/workspace';\n\nexport function WorkspaceSwitcher() {\n  const [open, setOpen] = useState(false);\n  const [selectedWorkspace, setSelectedWorkspace] = useState(null);\n  \n  const { data: workspaces } = useQuery({\n    queryKey: ['workspaces'],\n    queryFn: fetchWorkspaces\n  });\n\n  const handleSelect = async (workspace) => {\n    await setCurrentWorkspace(workspace.id);\n    setSelectedWorkspace(workspace);\n    setOpen(false);\n  };\n\n  // 구현 계속...\n}\n```",
        "testStrategy": "1. 워크스페이스 목록 로드 및 표시 테스트\n2. 워크스페이스 전환 기능 테스트\n3. 역할별 UI 요소 표시/숨김 테스트\n4. 워크스페이스 생성 및 관리 기능 테스트\n5. 멤버 초대 및 권한 변경 기능 테스트",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "대시보드 화면 구현",
        "description": "사용자 대시보드 UI 및 주요 메트릭 표시 기능 구현",
        "details": "1. 대시보드 레이아웃 및 카드 컴포넌트 구현\n2. 블로그 포스트 통계 및 상태 요약 표시\n3. 최근 활동 및 작업 목록 표시\n4. 채널별 성과 지표 시각화\n5. 대시보드 필터링 및 시간 범위 선택 기능\n6. 데이터 새로고침 기능 구현\n\n```tsx\n// app/dashboard/page.tsx\nimport { Suspense } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { PostsOverview } from '@/components/dashboard/posts-overview';\nimport { ChannelMetrics } from '@/components/dashboard/channel-metrics';\nimport { RecentActivity } from '@/components/dashboard/recent-activity';\nimport { DashboardSkeleton } from '@/components/skeletons';\n\nexport default function DashboardPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <h1 className=\"text-3xl font-bold\">대시보드</h1>\n      \n      <Tabs defaultValue=\"overview\">\n        <TabsList>\n          <TabsTrigger value=\"overview\">개요</TabsTrigger>\n          <TabsTrigger value=\"posts\">포스트</TabsTrigger>\n          <TabsTrigger value=\"channels\">채널</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"overview\" className=\"space-y-4\">\n          <div className=\"grid gap-4 md:grid-cols-2 lg:grid-cols-4\">\n            {/* 주요 메트릭 카드 */}\n            <Card>\n              <CardHeader className=\"pb-2\">\n                <CardTitle className=\"text-sm font-medium\">총 포스트</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <Suspense fallback={<div>로딩 중...</div>}>\n                  <PostsOverview />\n                </Suspense>\n              </CardContent>\n            </Card>\n            {/* 추가 카드들... */}\n          </div>\n          \n          {/* 추가 대시보드 컴포넌트들... */}\n        </TabsContent>\n        \n        {/* 다른 탭 콘텐츠... */}\n      </Tabs>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. 대시보드 컴포넌트 렌더링 테스트\n2. 데이터 로딩 및 표시 테스트\n3. 탭 전환 기능 테스트\n4. 필터링 및 시간 범위 선택 기능 테스트\n5. 반응형 레이아웃 테스트\n6. 데이터 새로고침 기능 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "포스트 목록 및 상세 화면 구현",
        "description": "블로그 포스트 목록 및 상세 화면 구현, 타임라인 및 SSE를 통한 실시간 업데이트 포함",
        "details": "1. 포스트 목록 페이지 구현 (필터링, 정렬, 페이지네이션 포함)\n2. 포스트 상세 페이지 구현\n3. SSE(Server-Sent Events)를 통한 실시간 업데이트 구현\n4. 포스트 진행 상태 타임라인 시각화 (ideate→draft→image→seo→publish)\n5. 실패 원인 표시 및 재시도 기능 구현\n6. 포스트 편집 및 삭제 기능 구현\n\n```tsx\n// app/posts/page.tsx - 포스트 목록 페이지\nimport { PostsTable } from '@/components/posts/posts-table';\nimport { PostsFilter } from '@/components/posts/posts-filter';\n\nexport default function PostsPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <h1 className=\"text-3xl font-bold\">포스트 관리</h1>\n      <PostsFilter />\n      <PostsTable />\n    </div>\n  );\n}\n\n// app/posts/[id]/page.tsx - 포스트 상세 페이지\nimport { notFound } from 'next/navigation';\nimport { PostDetail } from '@/components/posts/post-detail';\nimport { PostTimeline } from '@/components/posts/post-timeline';\nimport { PostActions } from '@/components/posts/post-actions';\n\nexport default async function PostDetailPage({ params }) {\n  const { id } = params;\n  // 포스트 데이터 가져오기\n  \n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-3xl font-bold\">포스트 상세</h1>\n        <PostActions id={id} />\n      </div>\n      \n      <div className=\"grid gap-6 md:grid-cols-3\">\n        <div className=\"md:col-span-2\">\n          <PostDetail id={id} />\n        </div>\n        <div>\n          <PostTimeline id={id} />\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// components/posts/post-timeline.tsx - SSE 구현\nimport { useEffect, useState } from 'react';\n\nexport function PostTimeline({ id }) {\n  const [events, setEvents] = useState([]);\n  \n  useEffect(() => {\n    const eventSource = new EventSource(`/api/posts/${id}/stream`);\n    \n    eventSource.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      setEvents(prev => [...prev, data]);\n    };\n    \n    return () => eventSource.close();\n  }, [id]);\n  \n  // 타임라인 렌더링 로직\n}\n```",
        "testStrategy": "1. 포스트 목록 로딩 및 표시 테스트\n2. 필터링 및 정렬 기능 테스트\n3. 포스트 상세 페이지 로딩 테스트\n4. SSE 연결 및 실시간 업데이트 테스트\n5. 타임라인 시각화 테스트\n6. 실패 상태 처리 및 재시도 기능 테스트\n7. 포스트 편집 및 삭제 기능 테스트",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "포스트 목록 페이지 구현",
            "description": "블로그 포스트 목록을 필터링, 정렬, 페이지네이션 기능과 함께 구현한다.",
            "dependencies": [],
            "details": "PostsTable 및 PostsFilter 컴포넌트를 활용하여 포스트 목록을 표시하고, 필터/정렬/페이지네이션 로직을 추가한다.",
            "status": "done",
            "testStrategy": "포스트 목록 로딩, 필터링, 정렬, 페이지네이션 동작을 각각 테스트한다."
          },
          {
            "id": 2,
            "title": "포스트 상세 페이지 구현",
            "description": "포스트의 상세 정보를 보여주는 페이지를 구현한다.",
            "dependencies": [
              "6.1"
            ],
            "details": "PostDetail, PostActions, PostTimeline 컴포넌트를 조합하여 상세 화면을 구성하고, 포스트 데이터 조회 및 표시 로직을 구현한다.",
            "status": "done",
            "testStrategy": "포스트 상세 페이지 진입, 데이터 로딩, UI 표시를 테스트한다."
          },
          {
            "id": 3,
            "title": "SSE 기반 실시간 타임라인 및 상태 업데이트 구현",
            "description": "SSE(Server-Sent Events)를 이용해 포스트 상태 변경 및 타임라인을 실시간으로 업데이트한다.",
            "dependencies": [
              "6.2"
            ],
            "details": "PostTimeline 컴포넌트에서 EventSource를 통해 서버와 연결하고, 상태 변경 이벤트를 수신하여 타임라인 UI를 실시간으로 갱신한다.",
            "status": "done",
            "testStrategy": "SSE 연결, 이벤트 수신, 타임라인 실시간 반영 여부를 테스트한다."
          },
          {
            "id": 4,
            "title": "포스트 실패 원인 표시 및 재시도 기능 구현",
            "description": "포스트 처리 실패 시 원인 메시지를 표시하고, 사용자가 재시도할 수 있는 기능을 제공한다.",
            "dependencies": [
              "6.3"
            ],
            "details": "실패 상태를 감지하여 상세 화면에 원인 메시지를 노출하고, 재시도 버튼 클릭 시 관련 API를 호출하여 상태를 갱신한다.\n<info added on 2025-09-04T09:43:44.655Z>\n## 완료된 작업들:\n\n### ✅ PostErrorDisplay 컴포넌트 구현\n- TDD 접근법으로 테스트 먼저 작성 (9개 테스트 모두 통과)\n- 실패한 타임라인 이벤트의 에러 메시지 표시\n- 재시도 횟수 및 마지막 재시도 시간 표시\n- 다양한 에러 타입 처리 (네트워크, API 타임아웃 등)\n- 접근성 고려 (ARIA labels, semantic structure)\n\n### ✅ PostDetail 컴포넌트 통합\n- 실패한 포스트 상태에서 PostErrorDisplay 자동 표시\n- 타임라인 이벤트에서 실패한 이벤트 자동 감지\n- TDD 테스트 작성 (4개 테스트 모두 통과)\n- 실패 상태가 아닌 경우 에러 정보 숨김 처리\n\n## 다음 단계:\n- PostActions 컴포넌트의 재시도 기능 개선 (Job ID 기반 재시도)\n- 재시도 후 상태 업데이트 검증\n- 통합 테스트 완료\n</info added on 2025-09-04T09:43:44.655Z>",
            "status": "done",
            "testStrategy": "실패 상태 시 원인 표시, 재시도 버튼 동작, 재시도 후 상태 변경을 테스트한다."
          },
          {
            "id": 5,
            "title": "포스트 편집 및 삭제 기능 구현",
            "description": "포스트를 편집하거나 삭제할 수 있는 기능을 상세 화면에 구현한다.",
            "dependencies": [
              "6.2"
            ],
            "details": "PostActions 컴포넌트에서 편집 및 삭제 버튼을 제공하고, 각 동작 시 API 호출 및 UI 갱신 로직을 구현한다.\n<info added on 2025-09-04T12:46:17.500Z>\n## 구현 완료 내용:\n\n### ✅ 포스트 편집 페이지 구현\n- TDD 방식으로 테스트 먼저 작성 (10개 테스트 모두 통과)\n- `/posts/[id]/edit` 경로로 편집 페이지 생성\n- 폼 검증 (제목, 내용 필수 입력, 길이 제한)\n- 기존 포스트 데이터 자동 채우기\n- 로딩 상태 및 에러 처리\n- 저장/취소 버튼 및 네비게이션\n\n### ✅ PostActions 컴포넌트 확인\n- 편집 버튼: `/posts/[id]/edit`로 이동\n- 삭제 버튼: 확인 다이얼로그와 함께 삭제\n- 재시도 버튼: 실패한 포스트 재생성\n- 기타 유틸리티 기능들 (복사, 공유, 다운로드)\n\n### ✅ API 연동\n- `useUpdatePost` 훅 활용\n- `api.posts.update` 메서드 연동\n- React Query를 통한 상태 관리 및 캐시 무효화\n\n### 📊 테스트 결과\n- 편집 페이지: 10개 테스트 모두 통과\n- PostActions: 6개 테스트 모두 통과\n- 전체 테스트: 146개 통과, 2개 실패 (98.6% 성공률)\n</info added on 2025-09-04T12:46:17.500Z>",
            "status": "done",
            "testStrategy": "편집/삭제 버튼 노출, 동작 성공/실패 시 UI 반영, 삭제 후 목록 갱신을 테스트한다."
          }
        ]
      },
      {
        "id": 7,
        "title": "포스트 생성 기능 구현",
        "description": "새로운 블로그 포스트 생성 폼 및 워크플로우 구현",
        "details": "1. 다단계 포스트 생성 폼 구현\n2. 폼 유효성 검사 (Zod 스키마 활용)\n3. 포스트 설정 및 옵션 구성 UI 구현\n4. 채널 선택 및 연결 기능 구현\n5. 포스트 미리보기 기능 구현\n6. 포스트 저장 및 제출 기능 구현\n\n```tsx\n// app/posts/create/page.tsx\nimport { PostCreateForm } from '@/components/posts/post-create-form';\n\nexport default function CreatePostPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <h1 className=\"text-3xl font-bold\">새 포스트 생성</h1>\n      <PostCreateForm />\n    </div>\n  );\n}\n\n// components/posts/post-create-form.tsx\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Textarea } from '@/components/ui/textarea';\nimport { ChannelSelector } from '@/components/channels/channel-selector';\n\nconst postSchema = z.object({\n  title: z.string().min(1, '제목을 입력해주세요'),\n  topic: z.string().min(1, '주제를 입력해주세요'),\n  keywords: z.string().optional(),\n  channelIds: z.array(z.string()).min(1, '최소 하나의 채널을 선택해주세요'),\n  // 추가 필드...\n});\n\nexport function PostCreateForm() {\n  const router = useRouter();\n  const [step, setStep] = useState(1);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  const form = useForm({\n    resolver: zodResolver(postSchema),\n    defaultValues: {\n      title: '',\n      topic: '',\n      keywords: '',\n      channelIds: [],\n    },\n  });\n  \n  const onSubmit = async (data) => {\n    setIsSubmitting(true);\n    try {\n      const response = await fetch('/api/posts', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n      });\n      \n      if (!response.ok) throw new Error('포스트 생성 실패');\n      \n      const result = await response.json();\n      router.push(`/posts/${result.id}`);\n    } catch (error) {\n      console.error('포스트 생성 오류:', error);\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n  \n  // 다단계 폼 렌더링 로직\n}\n```",
        "testStrategy": "1. 폼 유효성 검사 테스트\n2. 다단계 폼 네비게이션 테스트\n3. 채널 선택 기능 테스트\n4. 폼 제출 및 API 호출 테스트\n5. 오류 처리 및 사용자 피드백 테스트\n6. 폼 상태 유지 테스트",
        "priority": "high",
        "dependencies": [
          2,
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "채널 관리 기능 구현",
        "description": "블로그 채널 생성, 편집, 삭제 및 관리 기능 구현",
        "details": "1. 채널 목록 페이지 구현\n2. 채널 생성 폼 구현\n3. 채널 편집 및 설정 기능 구현\n4. 채널 연결 상태 및 인증 관리 구현\n5. 채널별 성과 지표 표시\n6. 채널 삭제 및 비활성화 기능 구현\n\n```tsx\n// app/channels/page.tsx\nimport { Suspense } from 'react';\nimport Link from 'next/link';\nimport { Button } from '@/components/ui/button';\nimport { ChannelsList } from '@/components/channels/channels-list';\nimport { ChannelsSkeleton } from '@/components/skeletons';\n\nexport default function ChannelsPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h1 className=\"text-3xl font-bold\">채널 관리</h1>\n        <Button asChild>\n          <Link href=\"/channels/create\">새 채널 추가</Link>\n        </Button>\n      </div>\n      \n      <Suspense fallback={<ChannelsSkeleton />}>\n        <ChannelsList />\n      </Suspense>\n    </div>\n  );\n}\n\n// app/channels/create/page.tsx\nimport { ChannelForm } from '@/components/channels/channel-form';\n\nexport default function CreateChannelPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <h1 className=\"text-3xl font-bold\">새 채널 추가</h1>\n      <ChannelForm />\n    </div>\n  );\n}\n\n// components/channels/channel-form.tsx\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { useRouter } from 'next/navigation';\nimport { Button } from '@/components/ui/button';\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\n\nconst channelSchema = z.object({\n  name: z.string().min(1, '채널 이름을 입력해주세요'),\n  type: z.enum(['medium', 'wordpress', 'tistory', 'brunch']),\n  // 추가 필드...\n});\n\nexport function ChannelForm({ channel }) {\n  const router = useRouter();\n  const isEditing = !!channel;\n  \n  const form = useForm({\n    resolver: zodResolver(channelSchema),\n    defaultValues: {\n      name: channel?.name || '',\n      type: channel?.type || '',\n      // 기타 필드 초기값...\n    },\n  });\n  \n  const onSubmit = async (data) => {\n    // 채널 생성 또는 업데이트 로직\n  };\n  \n  // 폼 렌더링 로직\n}\n```",
        "testStrategy": "1. 채널 목록 로딩 및 표시 테스트\n2. 채널 생성 폼 유효성 검사 테스트\n3. 채널 생성 및 편집 기능 테스트\n4. 채널 연결 상태 확인 테스트\n5. 채널 삭제 기능 테스트\n6. 채널 유형별 설정 옵션 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "미디어 업로드 기능 구현",
        "description": "Presigned URL을 사용한 미디어 파일 업로드 기능 구현",
        "details": "1. 미디어 업로드 컴포넌트 구현\n2. Presigned URL 요청 및 처리 로직 구현\n3. 파일 업로드 진행 상태 표시 기능 구현\n4. 이미지 미리보기 및 크롭 기능 구현\n5. 업로드된 미디어 관리 기능 구현\n6. 드래그 앤 드롭 업로드 지원\n\n```tsx\n// components/media/media-uploader.tsx\nimport { useState, useCallback } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport { Progress } from '@/components/ui/progress';\nimport { Button } from '@/components/ui/button';\nimport { Upload, X } from 'lucide-react';\n\nexport function MediaUploader({ onUploadComplete }) {\n  const [files, setFiles] = useState([]);\n  const [uploading, setUploading] = useState(false);\n  const [progress, setProgress] = useState({});\n  \n  const onDrop = useCallback(acceptedFiles => {\n    setFiles(prev => [...prev, ...acceptedFiles.map(file => \n      Object.assign(file, { preview: URL.createObjectURL(file) })\n    )]);\n  }, []);\n  \n  const { getRootProps, getInputProps } = useDropzone({\n    onDrop,\n    accept: {\n      'image/*': ['.jpeg', '.jpg', '.png', '.gif'],\n    },\n    maxSize: 10485760, // 10MB\n  });\n  \n  const uploadFile = async (file) => {\n    try {\n      // 1. Presigned URL 요청\n      const response = await fetch('/api/media/presigned-url', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          fileName: file.name,\n          contentType: file.type,\n        }),\n      });\n      \n      if (!response.ok) throw new Error('Presigned URL 요청 실패');\n      \n      const { url, fields, fileUrl } = await response.json();\n      \n      // 2. 폼 데이터 생성\n      const formData = new FormData();\n      Object.entries(fields).forEach(([key, value]) => {\n        formData.append(key, value);\n      });\n      formData.append('file', file);\n      \n      // 3. 파일 업로드\n      const uploadResponse = await fetch(url, {\n        method: 'POST',\n        body: formData,\n        // 업로드 진행 상태 추적\n        onUploadProgress: (event) => {\n          const percentCompleted = Math.round((event.loaded * 100) / event.total);\n          setProgress(prev => ({ ...prev, [file.name]: percentCompleted }));\n        },\n      });\n      \n      if (!uploadResponse.ok) throw new Error('파일 업로드 실패');\n      \n      return fileUrl;\n    } catch (error) {\n      console.error('업로드 오류:', error);\n      throw error;\n    }\n  };\n  \n  const handleUpload = async () => {\n    if (!files.length || uploading) return;\n    \n    setUploading(true);\n    \n    try {\n      const uploadedUrls = await Promise.all(files.map(uploadFile));\n      onUploadComplete(uploadedUrls);\n      setFiles([]);\n    } catch (error) {\n      console.error('업로드 오류:', error);\n    } finally {\n      setUploading(false);\n      setProgress({});\n    }\n  };\n  \n  // 컴포넌트 렌더링 로직\n}\n```",
        "testStrategy": "1. 파일 선택 및 드래그 앤 드롭 기능 테스트\n2. Presigned URL 요청 및 응답 처리 테스트\n3. 파일 업로드 진행 상태 표시 테스트\n4. 이미지 미리보기 기능 테스트\n5. 업로드 성공 및 실패 시나리오 테스트\n6. 파일 크기 및 유형 제한 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "설정 및 알림 기능 구현",
        "description": "사용자 설정 및 알림 관리 기능 구현",
        "details": "1. 사용자 프로필 설정 페이지 구현\n2. 알림 설정 및 기본 설정 구현\n3. 이메일 알림 구독 관리 기능 구현\n4. 알림 센터 및 실시간 알림 표시 기능 구현\n5. 사용자 테마 및 UI 설정 구현\n6. 계정 보안 설정 구현\n\n```tsx\n// app/settings/page.tsx\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { ProfileSettings } from '@/components/settings/profile-settings';\nimport { NotificationSettings } from '@/components/settings/notification-settings';\nimport { SecuritySettings } from '@/components/settings/security-settings';\nimport { AppearanceSettings } from '@/components/settings/appearance-settings';\n\nexport default function SettingsPage() {\n  return (\n    <div className=\"p-6 space-y-6\">\n      <h1 className=\"text-3xl font-bold\">설정</h1>\n      \n      <Tabs defaultValue=\"profile\">\n        <TabsList className=\"grid w-full grid-cols-4\">\n          <TabsTrigger value=\"profile\">프로필</TabsTrigger>\n          <TabsTrigger value=\"notifications\">알림</TabsTrigger>\n          <TabsTrigger value=\"appearance\">테마</TabsTrigger>\n          <TabsTrigger value=\"security\">보안</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"profile\">\n          <ProfileSettings />\n        </TabsContent>\n        \n        <TabsContent value=\"notifications\">\n          <NotificationSettings />\n        </TabsContent>\n        \n        <TabsContent value=\"appearance\">\n          <AppearanceSettings />\n        </TabsContent>\n        \n        <TabsContent value=\"security\">\n          <SecuritySettings />\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n\n// components/settings/notification-settings.tsx\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { Button } from '@/components/ui/button';\nimport { Form, FormControl, FormDescription, FormField, FormItem, FormLabel } from '@/components/ui/form';\nimport { Switch } from '@/components/ui/switch';\n\nconst notificationSchema = z.object({\n  emailNotifications: z.boolean(),\n  pushNotifications: z.boolean(),\n  postCompletionAlert: z.boolean(),\n  postFailureAlert: z.boolean(),\n  // 추가 설정...\n});\n\nexport function NotificationSettings() {\n  const form = useForm({\n    resolver: zodResolver(notificationSchema),\n    defaultValues: {\n      emailNotifications: true,\n      pushNotifications: false,\n      postCompletionAlert: true,\n      postFailureAlert: true,\n    },\n  });\n  \n  const onSubmit = async (data) => {\n    // 알림 설정 저장 로직\n  };\n  \n  // 폼 렌더링 로직\n}\n\n// components/layout/notification-center.tsx\nimport { useState, useEffect } from 'react';\nimport { Bell } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\n\nexport function NotificationCenter() {\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  \n  useEffect(() => {\n    // 알림 데이터 가져오기\n    // 실시간 알림 구독 설정\n  }, []);\n  \n  // 컴포넌트 렌더링 로직\n}\n```",
        "testStrategy": "1. 설정 페이지 탭 전환 테스트\n2. 설정 폼 유효성 검사 테스트\n3. 설정 저장 및 로드 테스트\n4. 알림 표시 및 읽음 처리 테스트\n5. 테마 변경 및 적용 테스트\n6. 보안 설정 변경 테스트",
        "priority": "low",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "테스트 자동화 및 CI/CD 파이프라인 개선",
        "description": "TDD 환경을 기반으로 테스트 자동화 프로세스를 개선하고 CI/CD 파이프라인을 최적화하는 작업",
        "details": "1. 기존 테스트 코드 분석 및 개선 영역 식별\n2. 테스트 커버리지 목표 설정 (90% 이상)\n3. 컴포넌트별 테스트 케이스 확장\n   - 설정 페이지 컴포넌트 테스트 추가\n   - 미디어 업로드 컴포넌트 테스트 강화\n   - 채널 관리 기능 테스트 구현\n   - 포스트 관련 컴포넌트 테스트 보강\n4. E2E 테스트 시나리오 구현\n   - 사용자 인증 흐름 테스트\n   - 포스트 생성 및 발행 흐름 테스트\n   - 설정 변경 및 적용 테스트\n5. GitHub Actions 워크플로우 최적화\n   - 테스트 병렬 실행 구성\n   - 테스트 캐싱 전략 구현\n   - 테스트 실패 시 알림 시스템 구축\n6. 테스트 보고서 자동화\n   - 테스트 결과 시각화 대시보드 구현\n   - 커버리지 리포트 자동 생성 및 PR 코멘트 추가\n7. 성능 테스트 통합\n   - 주요 페이지 로딩 성능 측정\n   - API 응답 시간 모니터링\n\n```yaml\n# .github/workflows/test-and-deploy.yml\nname: Test and Deploy\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run tests\n        run: npm test -- --coverage\n      - name: Upload coverage reports\n        uses: codecov/codecov-action@v3\n      - name: Comment PR with test results\n        if: github.event_name == 'pull_request'\n        uses: actions/github-script@v6\n        with:\n          script: |\n            const fs = require('fs');\n            const coverage = JSON.parse(fs.readFileSync('./coverage/coverage-summary.json'));\n            const totalCoverage = coverage.total.lines.pct;\n            \n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: `## 테스트 결과\\n- 커버리지: ${totalCoverage}%\\n- 상태: ${totalCoverage >= 90 ? '✅ 통과' : '❌ 실패'}`\n            });\n```",
        "testStrategy": "1. 테스트 코드 품질 검증\n   - 테스트 코드 자체의 가독성 및 유지보수성 평가\n   - 테스트 중복성 및 불필요한 테스트 식별\n\n2. 테스트 커버리지 검증\n   - 라인 커버리지 90% 이상 달성 확인\n   - 분기 커버리지 85% 이상 달성 확인\n   - 주요 비즈니스 로직에 대한 100% 커버리지 확인\n\n3. CI/CD 파이프라인 검증\n   - PR 생성 시 자동 테스트 실행 확인\n   - 테스트 실패 시 PR 병합 차단 기능 확인\n   - 테스트 결과 및 커버리지 리포트 자동 생성 확인\n\n4. 성능 테스트 검증\n   - 주요 페이지 로딩 시간 2초 이내 확인\n   - API 응답 시간 500ms 이내 확인\n   - 병렬 테스트 실행으로 인한 CI 시간 단축 확인\n\n5. 회귀 테스트 검증\n   - 기존 기능에 대한 회귀 테스트 자동화 확인\n   - 새로운 기능 추가 시 기존 테스트 통과 확인\n\n6. 테스트 환경 일관성 검증\n   - 로컬 개발 환경과 CI 환경의 테스트 결과 일치성 확인\n   - 테스트 데이터 및 모킹 전략의 일관성 확인",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-04T07:44:59.715Z",
      "updated": "2025-09-04T12:51:14.925Z",
      "description": "Tasks for master context"
    }
  }
}