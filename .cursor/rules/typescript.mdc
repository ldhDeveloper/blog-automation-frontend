---
description: TypeScript 타입 안전성 및 코드 품질 가이드라인
globs: frontend/**/*.{ts,tsx}, backend/src/**/*.ts
alwaysApply: true
---

- **타입 정의 규칙**
  ```typescript
  // ✅ DO: 명시적 인터페이스 정의
  interface CreateContentRequest {
    title: string;
    description?: string;
    status: ContentStatus;
    tags: string[];
  }
  
  interface ContentResponse {
    id: string;
    title: string;
    description: string | null;
    status: ContentStatus;
    user: {
      id: string;
      name: string;
    };
    createdAt: Date;
  }
  
  // ❌ DON'T: any 타입 사용
  function createContent(data: any): any {
    return contentService.create(data);
  }
  ```

- **제네릭 활용**
  ```typescript
  // ✅ DO: 재사용 가능한 제네릭 타입
  interface ApiResponse<T> {
    data: T;
    success: boolean;
    message?: string;
  }
  
  interface PaginatedResponse<T> extends ApiResponse<T[]> {
    pagination: {
      page: number;
      limit: number;
      total: number;
      totalPages: number;
    };
  }
  
  // ✅ DO: 제네릭 함수
  async function fetchData<T>(
    endpoint: string,
    validator: (data: unknown) => data is T
  ): Promise<ApiResponse<T>> {
    const response = await fetch(endpoint);
    const data = await response.json();
    
    if (!validator(data)) {
      throw new Error('Invalid response data');
    }
    
    return data;
  }
  ```

- **Union Types와 Type Guards**
  ```typescript
  // ✅ DO: 판별 유니온 타입
  type ContentStatus = 'draft' | 'generating' | 'ready' | 'published' | 'failed';
  
  interface ContentEvent {
    type: 'created' | 'updated' | 'published' | 'deleted';
    contentId: string;
    timestamp: Date;
  }
  
  interface ContentCreatedEvent extends ContentEvent {
    type: 'created';
    title: string;
    userId: string;
  }
  
  interface ContentPublishedEvent extends ContentEvent {
    type: 'published';
    publishUrl: string;
  }
  
  type AllContentEvents = ContentCreatedEvent | ContentPublishedEvent;
  
  // ✅ DO: Type Guard 함수
  function isContentCreatedEvent(event: ContentEvent): event is ContentCreatedEvent {
    return event.type === 'created';
  }
  
  function handleContentEvent(event: AllContentEvents) {
    if (isContentCreatedEvent(event)) {
      // event는 ContentCreatedEvent 타입으로 추론됨
      console.log(`새 콘텐츠 생성: ${event.title}`);
    }
  }
  ```

- **유틸리티 타입 활용**
  ```typescript
  // ✅ DO: 유틸리티 타입으로 타입 변환
  interface User {
    id: string;
    email: string;
    name: string;
    password: string;
    createdAt: Date;
    updatedAt: Date;
  }
  
  // 비밀번호 제외한 공개 사용자 정보
  type PublicUser = Omit<User, 'password'>;
  
  // 사용자 생성용 타입
  type CreateUserDto = Pick<User, 'email' | 'name' | 'password'>;
  
  // 선택적 업데이트용 타입
  type UpdateUserDto = Partial<Pick<User, 'name' | 'email'>>;
  
  // 필수 필드만 있는 타입
  type UserCore = Required<Pick<User, 'id' | 'email'>>;
  ```

- **Strict 모드 설정**
  ```json
  // ✅ DO: tsconfig.json에서 strict 모드 활성화
  {
    "compilerOptions": {
      "strict": true,
      "noImplicitAny": true,
      "noImplicitReturns": true,
      "noImplicitThis": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "exactOptionalPropertyTypes": true
    }
  }
  ```

- **함수 타입 정의**
  ```typescript
  // ✅ DO: 명시적 함수 시그니처
  type EventHandler<T> = (event: T) => void | Promise<void>;
  type AsyncOperation<T, R> = (input: T) => Promise<R>;
  type ValidationFunction<T> = (data: unknown) => data is T;
  
  // ✅ DO: 함수 오버로드
  function formatDate(date: Date): string;
  function formatDate(date: string): string;
  function formatDate(date: number): string;
  function formatDate(date: Date | string | number): string {
    const dateObj = new Date(date);
    return dateObj.toISOString().split('T')[0];
  }
  ```

- **모듈 타입 정의**
  ```typescript
  // ✅ DO: 모듈 선언
  declare module '*.svg' {
    const content: string;
    export default content;
  }
  
  declare module 'custom-library' {
    interface CustomLibraryOptions {
      apiKey: string;
      timeout?: number;
    }
    
    export function initialize(options: CustomLibraryOptions): void;
    export function process<T>(data: T): Promise<T>;
  }
  ```

- **에러 타입 정의**
  ```typescript
  // ✅ DO: 커스텀 에러 클래스
  abstract class AppError extends Error {
    abstract readonly statusCode: number;
    abstract readonly isOperational: boolean;
    
    constructor(message: string, public readonly context?: Record<string, unknown>) {
      super(message);
      this.name = this.constructor.name;
    }
  }
  
  class ValidationError extends AppError {
    readonly statusCode = 400;
    readonly isOperational = true;
    
    constructor(
      message: string,
      public readonly field: string,
      context?: Record<string, unknown>
    ) {
      super(message, context);
    }
  }
  
  class NotFoundError extends AppError {
    readonly statusCode = 404;
    readonly isOperational = true;
  }
  ```

- **React 컴포넌트 타입**
  ```tsx
  // ✅ DO: React 컴포넌트 타입 정의
  interface ButtonProps {
    variant: 'primary' | 'secondary' | 'danger';
    size?: 'sm' | 'md' | 'lg';
    disabled?: boolean;
    loading?: boolean;
    onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
    children: React.ReactNode;
  }
  
  export const Button: React.FC<ButtonProps> = ({
    variant,
    size = 'md',
    disabled = false,
    loading = false,
    onClick,
    children,
  }) => {
    return (
      <button
        className={`btn btn-${variant} btn-${size}`}
        disabled={disabled || loading}
        onClick={onClick}
      >
        {loading ? 'Loading...' : children}
      </button>
    );
  };
  
  // ❌ DON'T: 타입 없는 컴포넌트
  export const Button = (props) => {
    return <button {...props} />;
  };
  ```