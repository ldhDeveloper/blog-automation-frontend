# 테스트 분석 워크플로우 규칙

## 목적
테스트 작성 시 자동으로 실제 컴포넌트를 분석하고 동기화를 보장하는 워크플로우를 제공합니다.

## 테스트 작성 워크플로우

### 1단계: 컴포넌트 분석 (필수)
테스트를 작성하기 전에 반드시 다음을 수행:

```markdown
1. 실제 컴포넌트 파일 읽기
2. TypeScript interface 확인
3. 실제 렌더링 로직 파악
4. Props, state, 이벤트 핸들러 확인
5. 실제 텍스트, 클래스명, ARIA 속성 확인
```

### 2단계: 테스트 데이터 준비
실제 컴포넌트 분석 결과를 바탕으로:

```markdown
1. 실제 props interface에 맞는 Mock 데이터 생성
2. 실제 데이터 구조와 일치하는 테스트 데이터 작성
3. 실제 이벤트 핸들러 시그니처에 맞는 Mock 함수 생성
```

### 3단계: 테스트 작성
실제 컴포넌트와 정확히 일치하는 테스트 작성:

```markdown
1. 실제 텍스트와 정확히 일치하는 검증
2. 실제 DOM 구조와 일치하는 쿼리 사용
3. 실제 동작을 정확히 검증하는 테스트 케이스 작성
```

### 4단계: 검증 및 수정
테스트 실행 후 불일치 발견 시:

```markdown
1. 실제 컴포넌트와 테스트 간 차이점 파악
2. 테스트를 실제 컴포넌트에 맞게 수정
3. 수정된 테스트가 올바르게 작동하는지 확인
```

## 자동 분석 명령어

### 컴포넌트 분석 명령어
테스트 작성 전에 다음 명령어를 사용하여 컴포넌트를 분석:

```bash
# 1. 컴포넌트 파일 읽기
read_file target_file=src/components/[컴포넌트명].tsx

# 2. 관련 타입 파일 읽기
read_file target_file=src/types/[관련타입].ts

# 3. 기존 테스트 파일 읽기 (있는 경우)
read_file target_file=src/components/[컴포넌트명].test.tsx
```

### 테스트 실행 및 검증
```bash
# 개별 컴포넌트 테스트 실행
npm test src/components/[컴포넌트명].test.tsx

# 전체 테스트 실행
npm test --run
```

## 체크리스트 템플릿

### 테스트 작성 전 체크리스트
```markdown
## 컴포넌트 분석 체크리스트
- [ ] 실제 컴포넌트 파일을 읽었는가?
- [ ] TypeScript interface를 확인했는가?
- [ ] 실제 렌더링되는 텍스트를 확인했는가?
- [ ] Props의 기본값과 타입을 확인했는가?
- [ ] 이벤트 핸들러의 시그니처를 확인했는가?
- [ ] 실제 DOM 구조를 확인했는가?
- [ ] CSS 클래스명을 확인했는가?
- [ ] ARIA 속성을 확인했는가?
```

### 테스트 작성 중 체크리스트
```markdown
## 테스트 작성 체크리스트
- [ ] Mock 데이터가 실제 데이터 구조와 일치하는가?
- [ ] 테스트 텍스트가 실제 컴포넌트 텍스트와 일치하는가?
- [ ] Props가 실제 interface와 일치하는가?
- [ ] 이벤트 핸들러 호출이 실제 로직과 일치하는가?
- [ ] DOM 쿼리가 실제 구조와 일치하는가?
- [ ] 테스트가 실제 동작을 정확히 검증하는가?
```

## 자주 발생하는 불일치 패턴

### 1. 텍스트 불일치
```typescript
// ❌ 잘못된 예시
expect(screen.getByText('포스트를 불러오는 중...')).toBeInTheDocument();

// ✅ 올바른 예시 (실제 컴포넌트 확인 후)
expect(screen.getByText('타임라인 로딩 중...')).toBeInTheDocument();
```

### 2. Props 불일치
```typescript
// ❌ 잘못된 예시 (존재하지 않는 prop)
render(<PostsHeader onRefresh={mockRefresh} />);

// ✅ 올바른 예시 (실제 props만 사용)
render(<PostsHeader />);
```

### 3. 이벤트 핸들러 불일치
```typescript
// ❌ 잘못된 예시 (존재하지 않는 메서드)
expect(mockOnRefresh).toHaveBeenCalled();

// ✅ 올바른 예시 (실제 이벤트 핸들러)
expect(mockPush).toHaveBeenCalledWith('/posts/create');
```

### 4. DOM 구조 불일치
```typescript
// ❌ 잘못된 예시 (존재하지 않는 role)
expect(screen.getByRole('button', { name: /더 많은 작업/ })).toBeInTheDocument();

// ✅ 올바른 예시 (실제 DOM 구조 확인 후)
expect(screen.getByRole('button', { name: /메뉴 열기/ })).toBeInTheDocument();
```

## 디버깅 팁

### 1. 테스트 실패 시 실제 DOM 확인
```typescript
// 테스트 실패 시 실제 렌더링된 DOM 구조 확인
screen.debug();
```

### 2. 컴포넌트와 테스트 비교
```markdown
1. 실제 컴포넌트의 렌더링 결과 확인
2. 테스트에서 찾는 요소와 실제 요소 비교
3. 차이점을 찾아 테스트 수정
```

### 3. 점진적 테스트 작성
```markdown
1. 기본 렌더링 테스트부터 시작
2. 실제 컴포넌트와 일치하는지 확인
3. 점진적으로 복잡한 테스트 추가
4. 각 단계마다 실제 컴포넌트와 동기화 확인
```

## 마무리

테스트 작성 시 이 워크플로우를 따르면 
실제 컴포넌트와 일치하지 않는 테스트를 방지할 수 있습니다.
항상 실제 컴포넌트를 먼저 분석하고, 
실제와 정확히 일치하는 테스트를 작성하세요.