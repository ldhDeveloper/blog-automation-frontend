---
description: Supabase 인증, 데이터베이스, 보안 정책 가이드라인
globs: frontend/src/lib/supabase.ts, backend/src/infrastructure/database/supabase.service.ts, **/*.sql
alwaysApply: true
---

- **클라이언트 설정**
  - [supabase.ts](mdc:frontend/src/lib/supabase.ts) 참조하여 클라이언트 초기화
  - 프론트엔드: `anon key` 사용, 백엔드: `service role key` 사용
  - 환경 변수를 통한 설정 관리

- **인증 패턴**
  ```typescript
  // ✅ DO: 프론트엔드 인증 처리
  const signUp = async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    });
    
    if (error) {
      throw new Error(error.message);
    }
    
    return data;
  };
  
  // ✅ DO: 인증 상태 감지
  useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (event, session) => {
        if (event === 'SIGNED_IN') {
          setUser(session?.user ?? null);
        } else if (event === 'SIGNED_OUT') {
          setUser(null);
        }
      }
    );
    
    return () => subscription.unsubscribe();
  }, []);
  ```

- **Row Level Security (RLS) 정책**
  ```sql
  -- ✅ DO: 사용자별 데이터 보호
  CREATE POLICY "Users can only access their own content"
  ON content
  FOR ALL
  USING (auth.uid() = user_id);
  
  -- ✅ DO: 읽기 전용 공개 데이터
  CREATE POLICY "Anyone can read published content"
  ON content
  FOR SELECT
  USING (is_published = true);
  
  -- ❌ DON'T: 보안 정책 없는 테이블
  -- 모든 테이블에 적절한 RLS 정책 필수
  ```

- **백엔드에서 Supabase 사용**
  ```typescript
  // ✅ DO: 서비스 역할 키로 관리자 작업
  @Injectable()
  export class SupabaseService {
    private supabase: SupabaseClient;
    
    constructor(private configService: ConfigService) {
      this.supabase = createClient(
        this.configService.get('SUPABASE_URL'),
        this.configService.get('SUPABASE_SERVICE_ROLE_KEY'),
        {
          auth: {
            autoRefreshToken: false,
            persistSession: false,
          },
        }
      );
    }
    
    async createUser(userData: CreateUserData) {
      const { data, error } = await this.supabase.auth.admin.createUser({
        email: userData.email,
        password: userData.password,
        user_metadata: userData.metadata,
      });
      
      if (error) throw error;
      return data;
    }
  }
  ```

- **실시간 기능**
  ```typescript
  // ✅ DO: 실시간 구독 설정
  useEffect(() => {
    const subscription = supabase
      .channel('content-changes')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'content',
          filter: `user_id=eq.${user.id}`
        },
        (payload) => {
          console.log('변경 감지:', payload);
          // 상태 업데이트 로직
        }
      )
      .subscribe();
      
    return () => {
      subscription.unsubscribe();
    };
  }, [user.id]);
  ```

- **에러 처리**
  ```typescript
  // ✅ DO: Supabase 에러 타입 확인
  const handleSupabaseError = (error: PostgrestError | AuthError) => {
    if (error.code === 'PGRST116') {
      throw new NotFoundException('데이터를 찾을 수 없습니다');
    } else if (error.code === '23505') {
      throw new ConflictException('이미 존재하는 데이터입니다');
    }
    
    throw new InternalServerErrorException(error.message);
  };
  ```

- **보안 모범 사례**
  - `anon key`는 클라이언트에서만 사용
  - `service role key`는 서버 환경에서만 사용
  - RLS 정책으로 데이터 접근 제어
  - JWT 토큰 검증을 통한 사용자 인증
  - 민감한 작업은 백엔드에서 수행

- **데이터베이스 함수 및 트리거**
  ```sql
  -- ✅ DO: 데이터 일관성을 위한 트리거
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
  END;
  $$ language 'plpgsql';
  
  CREATE TRIGGER update_content_updated_at
      BEFORE UPDATE ON content
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  ```